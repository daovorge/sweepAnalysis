function [ tThr, tThrSE, tSlp, tSlpSE, tLSB, tRSB, tYFit, tResStr ] = JackSweep( tRLSMat, tSweepVal, tIsVisIncr )% Compute group threshold regression data using PowerDIVA scoring algorithm% coupled with jackknife estimators of errors on threshold and slope.% This function is designed to be invoked by Excel via a Matlab automation% server.  tRLSMat and tSweepVal are created in the automation server's% base workspace.  These are obtained from a pivot-table of RLS data% described in comments for SweepParams.  tLSB, tRSB, tYFit are the fitted% y-values and score bins with respect to the original sweep order.  That% way, a pivot chart of sweep data may be automatically converted to an RLS% data table to get regression data, and the results returned back to the% original pivotchart worksheet to add to the chart.% In most cases, this jackknife ith-deleted samples should re-use the score bounds returned% for the entire sample.  This way, the error term represents the dispersion of the% regression estimates.  Otherwise, when coercing new scoring for each deleted estimate,% the error terms represent the dispersion of the scoring algorithm.% tResStr contains regression data or "Scoring Failed"% Any error message strings are passed back as return value for client's% call to server.execute.  If there is no error you may safely handle the% variables returned to the workspace.% tRLSMat = reshape( tRLSMat', [ 10, 6, prod( size( tRLSMat ) ) / 10 / 6 ] ); % note transpose of tRLSMat% tN = size( tRLSMat, 3 );% tiDel = logical( ones( tN ) - ones( tN ) .* diag( ones( tN, 1 ) ) );% tStart = 0.25;% tEnd = 4;% tLinLog = 'log';% tSweepVal = abs( tSweepVal ); % this is a kludge for crossed and uncrossed sweeps in JHData% tSweepVal = -tSweepVal; % kludge to test neg sweep dirs[ tRLSMat, tThrOnLeft, tLinLog ] = SweepParams( tRLSMat, tSweepVal, tIsVisIncr );tN = size( tRLSMat, 3 );tiDel = logical( ones( tN ) - ones( tN ) .* diag( ones( tN, 1 ) ) );[ tThr, tSlp, range ] = HybridNewOldScore( SweepMat( tRLSMat ) );if ~isnan( tThr )    % Do jackknife analysis...    tLSB = range( 1 ); % to re-use the same scorebounds for each pass of jackknife    tRSB = range( 2 );	for i = 1:tN		ti = tiDel( :, i );	% 	[ thresh, slope, range ] = HybridNewOldScore( SweepMat( tRLSMat( :, :, ti ) ) ); % force re-scoring		[ thresh, slope, range ] = HybridNewOldScore( SweepMat( tRLSMat( :, :, ti ) ), tLSB, tRSB );		tThrD( i, 1 ) = thresh;		tSlpD( i, 1 ) = slope;	% 	disp( [ thresh, slope, range' ] );	end	tThrD = tThrD( ~isnan( tThrD ) );	tSlpD = tSlpD( ~isnan( tSlpD ) );	tND = length( tThrD );	tThrSE = sqrt( ( tND - 1 ) * sum( ( tThrD - mean( tThrD ) ) .^ 2 ) / tND );	tSlpSE = sqrt( ( tND - 1 ) * sum( ( tSlpD - mean( tSlpD ) ) .^ 2 ) / tND );    tIsLog = strcmp( tLinLog, 'log' );    tNBins = length( tSweepVal );    tYFit = tSlp * ( [ tLSB:tRSB ]' - tThr );	tStartBin = 1;	tEndBin = tNBins;    tStart = tSweepVal( tStartBin );    tEnd = tSweepVal( tEndBin );	if ~tThrOnLeft		tThr = tNBins - tThr + 1;		tLSB = tNBins - range(2) + 1;		tRSB = tNBins - range(1) + 1;		tYFit = flipud( tYFit );%         tStartBin = tNBins;%         tEndBin = 1;    end	if tIsLog		tStart = log10( tStart );		tEnd = log10( tEnd );    end	tThr = ( tThr - tStartBin ) / ( tEndBin - tStartBin ) * ( tEnd - tStart ) + tStart;	% get explicit confidence limits here, so we may estimate for log	% sweeps below...	tThrUp = ( tThr + tThrSE - tStartBin ) / ( tEndBin - tStartBin ) * ( tEnd - tStart ) + tStart;	tThrDn = ( tThr - tThrSE - tStartBin ) / ( tEndBin - tStartBin ) * ( tEnd - tStart ) + tStart;	if tIsLog		% always express threshold in stimulus units, even when semilog		tThr = 10 ^ tThr;		tThrUp = 10 ^ tThrUp;		tThrDn = 10 ^ tThrDn;		% slope of semilog is actually an exponential,		% so for convenience, leave semilog slope in bin units		% which are most convenient for plotting.	else		% otherwise, if linear, also express slope in stimulus units		tSlp = tSlp / ( tEnd - tStart ) * ( tNBins - 1 );	end	tThrSE = abs( tThrUp - tThrDn ) / 2.0; % Confidence interval is approximate for log sweeps.	tResStr = sprintf( 'Thr=%.3f(%.3f),Slp=%.3f(%.3f)', tThr, tThrSE, tSlp, tSlpSE);elsetThr = 0;tThrSE = 0;tSlp = 0;tSlpSE = 0;tLSB = 0;tRSB = 0;tYFit = 0;tResStr = sprintf( '%s', 'Scoring Failed');endfunction [ tRLSMat, tThrOnLeft, tLinLog ] = SweepParams( tRLSMat, tSweepVal, tIsVisIncr )% determines and returns sweep parameters needed for HybridNewOldScore from% an argument vector of sweep values.  Also re-orders tRLMat to make sure% it has increasing visibility. tIsVisIncr is 1 if response increases with% increasing sweep value.  Converts 2D table of ( [ Sr Si N1r N1i N2r N2i ] % nested within subject (or trial) ) x ( Number of sweep steps )% to a 3D matrix that is NSteps x 6(triad terms) x NSubjects(or NTrials).% The 2D table can be obtained from an Excel PivotTable laid out with row fields of LastName and Data and column% field SweepVal.tNBins = length( tSweepVal );tStart = tSweepVal( 1 );tEnd = tSweepVal( end );tLinLog = 'lin';tThrOnLeft = logical( 1 );if( sum( abs( tSweepVal - logspace( log10(tStart), log10(tEnd), tNBins ) ) ) ...        < sum( abs( tSweepVal - linspace( tStart, tEnd, tNBins ) ) ) )    tLinLog = 'log';endif ( ~tIsVisIncr & ( tStart < tEnd ) ) | ( tIsVisIncr & ( tStart > tEnd ) )    % HybridNewOldScore expects response data to be increasing...    % so flip the sweep order...    tRLSMat = fliplr( tRLSMat );    % and set the flag...    tThrOnLeft = logical( 0 );endtRLSMat = reshape( tRLSMat', [ tNBins, 6, prod( size( tRLSMat ) ) / tNBins / 6 ] ); % note transpose of tRLSMat% TO DO% x write comment regarding dimensionality of tRLSMat in Excel.% x tRLSMat should include sweep values to determine start, end, and loglin% x implement method to determine start, end, and loglin.  Loglin could be determined% x by abs( sweepvals - logspace ) > abs( sweepvals - linspace ).% Be sure to figure out how to handle decreasing visibility% suppress return value errors when condition doesn't score% return score bounds and y-values for regression line over regression range% Logic issues for sweep direction and visibility% HybridNewOldScore determines threshold in bin units for response amplitudes% arranged in increasing order of visibility by SweepParams% % the flag tIsVisIncr indicates whether increasing stimulus values cause increasing or decreasing visibility;% thus there are four sweep combinations:% start < end, incr => threshold on left% start > end, decr => threshold on left% start < end, decr => threshold on right% start > end, incr => threshold on right% So, we must make sure that conversion of regression parameters to stimulus units is done% with respect to the correct order in the original data